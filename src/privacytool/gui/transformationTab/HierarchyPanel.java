/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package privacytool.gui.transformationTab;

import java.awt.Color;
import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import privacytool.framework.data.Data;
import privacytool.framework.hierarchy.Hierarchy;
import privacytool.framework.hierarchy.distinct.AutoHierarchyImplDouble;
import privacytool.framework.hierarchy.distinct.AutoHierarchyImplString;
import privacytool.framework.hierarchy.distinct.HierarchyImplDouble;
import privacytool.framework.hierarchy.distinct.HierarchyImplString;
import privacytool.framework.hierarchy.ranges.AutoHierarchyImplRanges;
import privacytool.framework.hierarchy.ranges.HierarchyImplRanges;
import privacytool.framework.hierarchy.ranges.Range;
import privacytool.gui.ErrorWindow;

/**
 *
 * @author serafeim
 */
public class HierarchyPanel extends JPanel implements ActionListener {

    /**
     * Creates new form HierarchyPanel
     */
    
    Map<String, Hierarchy> hierarchies = new HashMap<>();
    Map<String, Map<Object, DefaultMutableTreeNode>> hierarchiesNodes = new HashMap<>();
    Map<String, DefaultTreeModel> trees = new HashMap<>();
    
    String clickedPoint = null;
    String firstPoint = null;
    String lastPoint = null;
    
    
    String curPoint = null;
    String parentPoint = null;

    boolean panelIsVisible = false;
    Data dataset = null;
    Hierarchy curHierarchy = null;
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        add = new javax.swing.JButton();
        edit = new javax.swing.JButton();
        remove = new javax.swing.JButton();
        clear = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTree1 = new javax.swing.JTree();
        hierarchiesCombobox = new javax.swing.JComboBox();
        jLabel1 = new javax.swing.JLabel();
        attributesCombobox = new javax.swing.JComboBox();
        reload = new javax.swing.JButton();

        setBorder(javax.swing.BorderFactory.createTitledBorder("Hierarchy"));
        setPreferredSize(new java.awt.Dimension(500, 502));

        add.setText("add");
        add.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addActionPerformed(evt);
            }
        });

        edit.setText("edit");
        edit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                editActionPerformed(evt);
            }
        });

        remove.setText("remove");
        remove.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeActionPerformed(evt);
            }
        });

        clear.setText("clear");
        clear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(49, 49, 49)
                .addComponent(add)
                .addGap(43, 43, 43)
                .addComponent(edit)
                .addGap(45, 45, 45)
                .addComponent(remove)
                .addGap(45, 45, 45)
                .addComponent(clear)
                .addContainerGap(93, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                .addComponent(add)
                .addComponent(edit)
                .addComponent(remove)
                .addComponent(clear))
        );

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("root");
        jTree1.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        jTree1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                jTree1MousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                jTree1MouseReleased(evt);
            }
        });
        jTree1.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                jTree1ValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(jTree1);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jScrollPane1))
        );

        hierarchiesCombobox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        hierarchiesCombobox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                hierarchiesComboboxActionPerformed(evt);
            }
        });

        jLabel1.setText("on Attribute:");

        attributesCombobox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        attributesCombobox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                attributesComboboxActionPerformed(evt);
            }
        });

        reload.setText("Reload");
        reload.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                reloadActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(hierarchiesCombobox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(attributesCombobox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(reload))
                            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(hierarchiesCombobox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1)
                    .addComponent(attributesCombobox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(reload))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    
    private void editActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_editActionPerformed
        System.out.println("edit");
        System.out.println("current " + curPoint);
        System.out.println("parent " + parentPoint);
        if(curPoint == null){
            ErrorWindow.showErrorWindow("Please select a node first");
            return;
        }
        DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();
        
        Object oldItem = null;
        boolean validInput = false;
        boolean outOfBoundsCheck = false;
        String value = curPoint;
        Object newItem = null;
        Object parentItem = null;
        JFrame frame = new JFrame("Edit Dialog");
        String selectedItem = null;
        while(!validInput || !outOfBoundsCheck){
            validInput = true;
            outOfBoundsCheck = true;
            
            value = JOptionPane.showInputDialog(frame, "Edit node's value:", value);
            if(value == null) return; //cancelled by user.
            selectedItem = (String)hierarchiesCombobox.getSelectedItem();
            
            value = value.replaceAll("\\s","");
          //  System.out.println(value);
            
            if(hierarchies.get(selectedItem).getRoot() instanceof Range){
                oldItem = new Range();
                String[] tokens = curPoint.split("-");
                ((Range)oldItem).setLowerBound(Double.parseDouble(tokens[0]));
                ((Range)oldItem).setUpperBound(Double.parseDouble(tokens[1]));
                
                
                tokens = value.split("-");
                //System.out.println("edw " + Double.parseDouble(tokens[0]) + " " + Double.parseDouble(tokens[1]));
                if(tokens.length != 2){
                    ErrorWindow.showErrorWindow("Wrong format type in range");
                    return;
                }
                newItem = new Range();
                ((Range)newItem).setLowerBound(Double.parseDouble(tokens[0]));
                ((Range)newItem).setUpperBound(Double.parseDouble(tokens[1]));
                
                if(parentPoint != null){
                    tokens = parentPoint.split("-");
                    parentItem = new Range();
                    ((Range)parentItem).setLowerBound(Double.parseDouble(tokens[0]));
                    ((Range)parentItem).setUpperBound(Double.parseDouble(tokens[1]));

                    System.out.println("parent =  " + parentItem.toString());
                    
                    ///////////////////////////////////////////////////////////
                    //check if bounds are compatible with the parent
                    /*if(((Range)newItem).getUpperBound() > ((Range)parentItem).getUpperBound() ||
                            ((Range)newItem).getLowerBound() < ((Range)parentItem).getLowerBound()){
                        JOptionPane.showMessageDialog(null, "Please, adjust node's bounds to those of the parent",
                                "Warning - Out of bounds", 1);
                        outOfBoundsCheck = false;
                    }*/
                    if(((Range)newItem).getUpperBound() > ((Range)parentItem).getUpperBound() || ((Range)newItem).getLowerBound() < ((Range)parentItem).getLowerBound()){
                        
                    }
                }
                
            }else if (hierarchies.get(selectedItem).getRoot() instanceof String){    
                newItem = value;
                oldItem = curPoint;
                Hierarchy h = hierarchies.get(selectedItem);
                if(h.contains(newItem)){
                    JOptionPane.showMessageDialog(null, "Value already exists, please retype", "Warning", 1);
                    validInput = false;                
                }
            }else{
                newItem = Double.parseDouble(value);
                oldItem = Double.parseDouble(curPoint);
                Hierarchy h = hierarchies.get(selectedItem);
                if(h.contains(newItem)){
                    JOptionPane.showMessageDialog(null, "Value already exists, please retype", "Warning", 1);
                    validInput = false;                
                }
            }
            
            
        }
        System.out.println(oldItem + " changed to " + newItem);
        Hierarchy h = hierarchies.get(selectedItem);
        h.edit(oldItem, newItem);

        //set new name to graphic node
        Map<Object, DefaultMutableTreeNode> nodesMap = hierarchiesNodes.get(selectedItem);
        DefaultMutableTreeNode node = nodesMap.get(oldItem);
        node.setUserObject(newItem.toString());
        nodesMap.remove(oldItem);
        nodesMap.put(newItem, node);
        model.nodeChanged(node);
        model.reload();//REMOVE
        curPoint = newItem.toString();                                  
    }//GEN-LAST:event_editActionPerformed

    
    private void clearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearActionPerformed
        System.out.println("clear hierarchy");
        String selectedItem = (String)hierarchiesCombobox.getSelectedItem();
        Hierarchy h = hierarchies.get(selectedItem);
        h.clear();
        
        Map<Object, DefaultMutableTreeNode> nodesMap = hierarchiesNodes.get(selectedItem);
        DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();
         
        Map<Object, DefaultMutableTreeNode> newMap = new HashMap<>();
        //remove nodes
        for(Object o : nodesMap.keySet()){
            DefaultMutableTreeNode node = nodesMap.get(o);
            if(o == h.getRoot()){   //skip root
                newMap.put(o, node);
                continue;
            }
            
            model.removeNodeFromParent(node);
            //nodesMap.remove(o);
        }       
        hierarchiesNodes.put(h.getName(), newMap);
        newMap = null;
        curPoint = null;
    }//GEN-LAST:event_clearActionPerformed

    
    private void addActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addActionPerformed
        System.out.println("current " + curPoint);
        System.out.println("parent " + parentPoint);
        if(curPoint == null){
            ErrorWindow.showErrorWindow("Please select a node first");
            return;
        }
        DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();
        
        boolean validInput = false;
        boolean outOfBoundsCheck = false;
        String value = null;
        String selectedItem = null;
        Object newItem = null;
        Object parentItem = null;
        JFrame frame = new JFrame("Input Dialog");
        while(!validInput || !outOfBoundsCheck){
            validInput = true;
            outOfBoundsCheck = true;
            
            value = JOptionPane.showInputDialog(frame, "Give new node's value:", value);
            if(value == null) return; //cancelled by user.
            selectedItem = (String)hierarchiesCombobox.getSelectedItem();
            
            value = value.replaceAll("\\s","");
          //  System.out.println(value);
            
            if(hierarchies.get(selectedItem).getRoot() instanceof Range){
                String[] tokens = value.split("-");
                //System.out.println("edw " + Double.parseDouble(tokens[0]) + " " + Double.parseDouble(tokens[1]));
                newItem = new Range();
                if(tokens.length != 2){
                    ErrorWindow.showErrorWindow("Wrong format of range");
                    return;
                }
                ((Range)newItem).setLowerBound(Double.parseDouble(tokens[0]));
                ((Range)newItem).setUpperBound(Double.parseDouble(tokens[1]));
                
                tokens = curPoint.split("-");
                parentItem = new Range();
                ((Range)parentItem).setLowerBound(Double.parseDouble(tokens[0]));
                ((Range)parentItem).setUpperBound(Double.parseDouble(tokens[1]));
                
                //check if bounds are compatible with the parent
                if(((Range)newItem).getUpperBound() > ((Range)parentItem).getUpperBound() ||
                        ((Range)newItem).getLowerBound() < ((Range)parentItem).getLowerBound()){
                    JOptionPane.showMessageDialog(null, "Please, adjust new node's bounds to those of the parent",
                            "Warning - Out of bounds", 1);
                    outOfBoundsCheck = false;
                }
                
            }else if (hierarchies.get(selectedItem).getRoot() instanceof String){
                newItem = value;
                parentItem = curPoint;
            }
            else{
                newItem = Double.parseDouble(value);
                parentItem = Double.parseDouble(curPoint);
            }
            
            Hierarchy h = hierarchies.get(selectedItem);
            if(h.contains(newItem)){
                JOptionPane.showMessageDialog(null, "Value already exists, please retype", "Warning", 1);
                validInput = false;                
            }
        }
        //String selectedItem = (String)jComboBox1.getSelectedItem();
        
        //Double newItem = Double.parseDouble(value);
        Map<Object, DefaultMutableTreeNode> nodesMap = hierarchiesNodes.get(selectedItem);
        Hierarchy h = hierarchies.get(selectedItem);
        h.add(newItem, parentItem);

        DefaultMutableTreeNode treeNode = new DefaultMutableTreeNode(newItem.toString());
        nodesMap.put(newItem, treeNode);
        model.insertNodeInto(treeNode, nodesMap.get(h.getParent(newItem)), 
                        nodesMap.get(h.getParent(newItem)).getChildCount());  
    }//GEN-LAST:event_addActionPerformed

    
    private void removeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeActionPerformed
        if(curPoint == null){
            ErrorWindow.showErrorWindow("Please select a node first");
            return;
        }
        
        Object removedItem = null;
        
        String selectedItem = (String)hierarchiesCombobox.getSelectedItem();
        /*
        if(hierarchies.get(selectedItem).getNodesType().equals("int") || hierarchies.get(selectedItem).getNodesType().equals("double")){
            removedItem = Double.parseDouble(curPoint);
        } else if (hierarchies.get(selectedItem).getNodesType().equals("string")){
            removedItem = curPoint;
        } else if (){
            
        }
        */
        if(hierarchies.get(selectedItem).getHierarchyType().equals("distinct")){
            if(hierarchies.get(selectedItem).getNodesType().equals("int") ||
                    hierarchies.get(selectedItem).getNodesType().equals("double")){
                removedItem = Double.parseDouble(curPoint);
            }
            else if(hierarchies.get(selectedItem).getNodesType().equals("string")){
                removedItem = curPoint;
            }
        }else if(hierarchies.get(selectedItem).getHierarchyType().equals("range")){
            String[] parts = curPoint.split("-");
            
            if(parts.length == 2){
                removedItem = new Range();
                ((Range)removedItem).setLowerBound(Double.parseDouble(parts[0].trim()));
                ((Range)removedItem).setUpperBound(Double.parseDouble(parts[1].trim()));
            }
            
        }
        
        Hierarchy h = hierarchies.get(selectedItem);
        
        System.out.println("HierarchyPane: " + removedItem + " " + hierarchies.get(selectedItem).getHierarchyType());
        
        Map<Integer, Set<Object>> nodesToDelete = h.remove(removedItem);
        if(nodesToDelete != null){
            DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();
            Map<Object, DefaultMutableTreeNode> nodesMap = hierarchiesNodes.get(selectedItem);

            for (Integer i : nodesToDelete.keySet()){
                for(Object node : nodesToDelete.get(i)){
                    model.removeNodeFromParent(nodesMap.get(node));
                    nodesMap.remove(node);
                }
            }
        }
        else{
            ErrorWindow.showErrorWindow("You cannot remove root node");
        }
    
    }//GEN-LAST:event_removeActionPerformed

    
    
    
    private void jTree1MousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTree1MousePressed
        // TODO add your handling code here:
        TreePath path = jTree1.getPathForLocation(evt.getX(), evt.getY());
        if (path != null){
            firstPoint = parsePoint(path.getLastPathComponent().toString());
            System.out.println("pressed" + " " + firstPoint);
        }
    }//GEN-LAST:event_jTree1MousePressed

    
    private void jTree1MouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTree1MouseReleased
        // TODO add your handling code here:
        String selectedItem = null;
        Map<Integer,Set<Object>> bfs = null;
        
        
        TreePath path = jTree1.getPathForLocation(evt.getX(), evt.getY());
        if (path != null){
            lastPoint = parsePoint(path.getLastPathComponent().toString());
            if ( firstPoint != null && lastPoint != null ){
                if (firstPoint.equals(lastPoint)){
                    curPoint = parsePoint(firstPoint);
                    if(path.getParentPath() != null){
                        parentPoint = parsePoint(path.getParentPath().getPathComponent(path.getPathCount()-2).toString());
                    }
                }
                else{
                    selectedItem = (String)hierarchiesCombobox.getSelectedItem();
                    Hierarchy h = hierarchies.get(selectedItem);
                    System.out.println("selected Item = " + selectedItem);
                    if(h.getHierarchyType().equals("distinct")){
                        if (h.getNodesType().equals("string")){
                            bfs = h.dragAndDrop(firstPoint,lastPoint);
                        }
                        else{
                            bfs = h.dragAndDrop(Double.parseDouble(firstPoint),Double.parseDouble(lastPoint));
                        }
                    }
                    else if (h.getHierarchyType().equals("range")){
                        String[] parts = firstPoint.split("-");
                        Range firstRange = new Range();
                        firstRange.setLowerBound(Double.parseDouble(parts[0].trim()));
                        firstRange.setUpperBound(Double.parseDouble(parts[1].trim()));
                        
                        parts = lastPoint.split("-");
                        Range lastRange = new Range();
                        lastRange.setLowerBound(Double.parseDouble(parts[0].trim()));
                        lastRange.setUpperBound(Double.parseDouble(parts[1].trim()));
                        bfs = h.dragAndDrop(firstRange, lastRange);
                    }
                    
                    if(bfs != null){
                        DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();
                        Map<Object, DefaultMutableTreeNode> nodesMap = hierarchiesNodes.get(selectedItem);
                        for (Integer i : bfs.keySet()){
                            for(Object node : bfs.get(i)){
                                model.removeNodeFromParent(nodesMap.get(node));
                                nodesMap.remove(node);
                            }
                        }
                        
                        for (Integer i : bfs.keySet()){
                            for(Object node : bfs.get(i)){
                                DefaultMutableTreeNode treeNode = new DefaultMutableTreeNode(node.toString());
                                nodesMap.put(node, treeNode);
                                model.insertNodeInto(treeNode, nodesMap.get(h.getParent(node)),nodesMap.get(h.getParent(node)).getChildCount()); 
                            }
                        }
                        
                    }
                    else{
                        ErrorWindow.showErrorWindow("You cannot change a father with a child");
                    }             
                }
            }
        }
    }//GEN-LAST:event_jTree1MouseReleased

    private void jTree1ValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_jTree1ValueChanged
        // TODO add your handling code here:
        
        //sou dinei to path.....
        /*
        System.out.println("value changed");
        System.out.println("new " + evt.getNewLeadSelectionPath());
        System.out.println("old" + evt.getOldLeadSelectionPath());
        System.out.println("path" + evt.getPath());
        */
       
    }//GEN-LAST:event_jTree1ValueChanged

    private void reloadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_reloadActionPerformed
        String column = (String)attributesCombobox.getSelectedItem();
        String selectedHierarchy = (String)hierarchiesCombobox.getSelectedItem();
        Hierarchy h = hierarchies.get(selectedHierarchy);
        h.computeWeights(dataset, column);
        visualizeWeights(hierarchiesNodes.get(selectedHierarchy), h);
    }//GEN-LAST:event_reloadActionPerformed

    private void attributesComboboxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_attributesComboboxActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_attributesComboboxActionPerformed

    private void hierarchiesComboboxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_hierarchiesComboboxActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_hierarchiesComboboxActionPerformed

    private String parsePoint(String point){
        int i = point.indexOf("[");
        if(i == -1)
            return point;
        //System.out.println(point.substring(0, i) + " size: " + point.substring(0, i).length());
        return point.substring(0, i).trim();
        
    }
    
      
      

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton add;
    private javax.swing.JComboBox attributesCombobox;
    private javax.swing.JButton clear;
    private javax.swing.JButton edit;
    private javax.swing.JComboBox hierarchiesCombobox;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTree jTree1;
    private javax.swing.JButton reload;
    private javax.swing.JButton remove;
    // End of variables declaration//GEN-END:variables

   
    public HierarchyPanel() {
        
        initComponents();
//        jTree1.setCellRenderer(new RedTreeCellRenderer());
        hierarchiesCombobox.removeAllItems();
        hierarchiesCombobox.addItemListener(new ItemListener() {

            @Override
            public void itemStateChanged(ItemEvent e) {
                if (e.getStateChange() == ItemEvent.SELECTED) {
                    String item = (String)e.getItem();
                    showHierarchy(hierarchies.get(item));
                    initAttributesCombo();
                }
            }
        });
           
        jPanel1.setVisible(false);
        hierarchiesCombobox.setVisible(false);
        
        jPanel2.setVisible(false);
        
        jLabel1.setVisible(false);
        reload.setVisible(false);
        attributesCombobox.removeAllItems();
        
        attributesCombobox.setVisible(false);
        attributesCombobox.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                if (e.getStateChange() == ItemEvent.SELECTED) {
                    String column = (String)e.getItem();
                    String selectedHierarchy = (String)hierarchiesCombobox.getSelectedItem();
                    Hierarchy h = hierarchies.get(selectedHierarchy);
                    h.computeWeights(dataset, column);
                    visualizeWeights(hierarchiesNodes.get(selectedHierarchy), h);
                }            
            }
        });
           
    }
    public void showHierarchy(Hierarchy h){
        System.out.println("Showing Hierarchy tree: " + h.getName());
        
        jTree1.setModel(trees.get(h.getName()));
    }
    
    public void createHierarchyTree(Hierarchy h){
        System.out.println("Creating hierarchy tree: " + h.getName());
        
        this.panelIsVisible = true;
        jPanel1.setVisible(true);
        hierarchiesCombobox.setVisible(true);
        jPanel2.setVisible(true);
        
        
        Map<Object, DefaultMutableTreeNode> nodesMap = new HashMap<>();
        
        System.out.println(h.getHierarchyType());
        System.out.println(h.getNodesType());
        if ( h.getHierarchyType().equals("distinct")){
            if ( h.getNodesType().equals("double") || h.getNodesType().equals("string") ){
                DefaultMutableTreeNode root = new DefaultMutableTreeNode(h.getRoot().toString());
                nodesMap.put(h.getRoot(), root);
                //System.out.println(h.getRoot().toString());

                jTree1.setModel(new javax.swing.tree.DefaultTreeModel(root));

                DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();
                trees.put(h.getName(), model);

                for(Integer level : (Set<Integer>)h.getAllParents().keySet()){
                    //System.out.println("HERE: " + level  + " " + h.getAllParents().get(level));         

                    for(Object node : (ArrayList<Object>)   h.getAllParents().get(level)){

                        Object parent = h.getParent(node);
                        //if node is not the root
                        if(parent != null){
                            DefaultMutableTreeNode treeNode = new DefaultMutableTreeNode(node.toString());
                            nodesMap.put(node, treeNode);
                            model.insertNodeInto(treeNode, nodesMap.get(parent), nodesMap.get(parent).getChildCount());
                            //System.out.println(node + " has parent " + parent);
                        }

                        //add nodes of last level               
                        //System.out.println("LEVEL " + level);
                        if(level == h.getAllParents().keySet().size()-1){
                            if (h.getChildren(node) != null){
                                //System.out.println("LEVEL2 " + node + " " + h.getChildren(node));

                                for(Object childNode : h.getChildren(node)){
                                    //System.out.println("LEVEL3 " + level);
        //                          //System.out.println(childNode + " -> " + h.getParent(childNode));

                                    DefaultMutableTreeNode treeNode2 = new DefaultMutableTreeNode(childNode.toString());
                                    nodesMap.put(childNode, treeNode2);
                                    model.insertNodeInto(treeNode2, nodesMap.get(h.getParent(childNode)), nodesMap.get(h.getParent(childNode)).getChildCount());

                                }
                            }
                        }

                    }   
                }       
                hierarchiesNodes.put(h.getName(), nodesMap);
            }
            else{
                DefaultMutableTreeNode root = new DefaultMutableTreeNode((int)Double.parseDouble(h.getRoot().toString()));
                nodesMap.put(h.getRoot(), root);
                System.out.println("root = " + (int)Double.parseDouble(h.getRoot().toString()));

                jTree1.setModel(new javax.swing.tree.DefaultTreeModel(root));

                DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();
                trees.put(h.getName(), model);

                for(Integer level : (Set<Integer>)h.getAllParents().keySet()){
                    //System.out.println("HERE: " + level  + " " + h.getAllParents().get(level));         

                    for(Object node : (ArrayList<Object>)   h.getAllParents().get(level)){

                        Object parent = h.getParent(node);
                        //if node is not the root
                        if(parent != null){
                            DefaultMutableTreeNode treeNode = new DefaultMutableTreeNode((int)Double.parseDouble(node.toString()));
                            nodesMap.put(node, treeNode);
                            model.insertNodeInto(treeNode, nodesMap.get(parent), nodesMap.get(parent).getChildCount());
                            //System.out.println(node + " has parent " + parent);
                        }

                        //add nodes of last level               
                        //System.out.println("LEVEL " + level);
                        if(level == h.getAllParents().keySet().size()-1){
                            if (h.getChildren(node) != null){
                                //System.out.println("LEVEL2 " + node + " " + h.getChildren(node));

                                for(Object childNode : h.getChildren(node)){
                                    //System.out.println("LEVEL3 " + level);
        //                          //System.out.println(childNode + " -> " + h.getParent(childNode));

                                    DefaultMutableTreeNode treeNode2 = new DefaultMutableTreeNode((int)Double.parseDouble(childNode.toString()));
                                    nodesMap.put(childNode, treeNode2);
                                    model.insertNodeInto(treeNode2, nodesMap.get(h.getParent(childNode)), nodesMap.get(h.getParent(childNode)).getChildCount());

                                }
                            }
                        }

                    }   
                }       
                hierarchiesNodes.put(h.getName(), nodesMap);
            }
        }
        else{
            if ( h.getNodesType().equals("double") || h.getNodesType().equals("string") ){
                DefaultMutableTreeNode root = new DefaultMutableTreeNode(h.getRoot().toString());
                nodesMap.put(h.getRoot(), root);
                //System.out.println(h.getRoot().toString());

                jTree1.setModel(new javax.swing.tree.DefaultTreeModel(root));

                DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();
                trees.put(h.getName(), model);

                for(Integer level : (Set<Integer>)h.getAllParents().keySet()){
                    //System.out.println("HERE: " + level  + " " + h.getAllParents().get(level));         
                    for(Object node : (ArrayList<Object>)   h.getAllParents().get(level)){
                        Object parent = h.getParent(node);
                        //if node is not the root
                        if(parent != null){
                            DefaultMutableTreeNode treeNode = new DefaultMutableTreeNode(node.toString());
                            nodesMap.put(node, treeNode);
                            model.insertNodeInto(treeNode, nodesMap.get(parent), nodesMap.get(parent).getChildCount());
                            //System.out.println(node + " has parent " + parent);
                        }

                        //add nodes of last level               
                        //System.out.println("LEVEL " + level);
                        if(level == h.getAllParents().keySet().size()-1){
                            if (h.getChildren(node) != null){
                                //System.out.println("LEVEL2 " + node + " " + h.getChildren(node));

                                for(Object childNode : h.getChildren(node)){
                                    //System.out.println("LEVEL3 " + level);
            //                      //System.out.println(childNode + " -> " + h.getParent(childNode));

                                    DefaultMutableTreeNode treeNode2 = new DefaultMutableTreeNode(childNode.toString());
                                    nodesMap.put(childNode, treeNode2);
                                    model.insertNodeInto(treeNode2, nodesMap.get(h.getParent(childNode)), nodesMap.get(h.getParent(childNode)).getChildCount());
                                }
                            }
                        }
                    }   
                }       
                hierarchiesNodes.put(h.getName(), nodesMap);
            }
            else{
                Range r = new Range();
                r = r.parseRange(h.getRoot().toString()); 
                DefaultMutableTreeNode root = new DefaultMutableTreeNode(r.lowerBound.intValue() +"-"+ r.upperBound.intValue());
                nodesMap.put(h.getRoot(), root);
                //System.out.println(h.getRoot().toString());

                jTree1.setModel(new javax.swing.tree.DefaultTreeModel(root));

                DefaultTreeModel model = (DefaultTreeModel) jTree1.getModel();
                trees.put(h.getName(), model);

                for(Integer level : (Set<Integer>)h.getAllParents().keySet()){
                    //System.out.println("HERE: " + level  + " " + h.getAllParents().get(level));         
                    for(Object node : (ArrayList<Object>)   h.getAllParents().get(level)){
                        Object parent = h.getParent(node);
                        //if node is not the root
                        if(parent != null){
                            r = r.parseRange(node.toString());
                            DefaultMutableTreeNode treeNode = new DefaultMutableTreeNode(r.lowerBound.intValue() +"-"+ r.upperBound.intValue());
                            nodesMap.put(node, treeNode);
                            model.insertNodeInto(treeNode, nodesMap.get(parent), nodesMap.get(parent).getChildCount());
                            //System.out.println(node + " has parent " + parent);
                        }

                        //add nodes of last level               
                        //System.out.println("LEVEL " + level);
                        if(level == h.getAllParents().keySet().size()-1){
                            if (h.getChildren(node) != null){
                                //System.out.println("LEVEL2 " + node + " " + h.getChildren(node));

                                for(Object childNode : h.getChildren(node)){
                                    //System.out.println("LEVEL3 " + level);
            //                      //System.out.println(childNode + " -> " + h.getParent(childNode));
                                    r = r.parseRange(childNode.toString());
                                    DefaultMutableTreeNode treeNode2 = new DefaultMutableTreeNode(r.lowerBound.intValue() +"-"+ r.upperBound.intValue());
                                    nodesMap.put(childNode, treeNode2);
                                    model.insertNodeInto(treeNode2, nodesMap.get(h.getParent(childNode)), nodesMap.get(h.getParent(childNode)).getChildCount());
                                }
                            }
                        }
                    }   
                }       
                hierarchiesNodes.put(h.getName(), nodesMap);
            }
        }
    }
    
    
    public void readHierarchy(String file){

        Hierarchy h = null;

        //read metadata of file to determine which type of hierarchy to use
        List<String> results = findHierarchyType(file);

        
//        System.out.println(results); 
        if(results.size() != 2){
            ErrorWindow.showErrorWindow("Error reading metadata in hierarchy file");
            return;
        }
        
        boolean distinct = false;
        String type = null;
        
        for(String res : results){
            if(res.equalsIgnoreCase("distinct")){
                distinct = true;
            }
            if(res.equalsIgnoreCase("int") || res.equalsIgnoreCase("double") || res.equalsIgnoreCase("string")){
                type = res;
            }
        }
        
        //create distinct hierarchy according to type
        if(distinct){
            if(type == null){
                ErrorWindow.showErrorWindow("Error reading metadata: no valid type found");
                return;
            }
            else if(type.equalsIgnoreCase("string")){
                h = new HierarchyImplString(file);
                h.setHierachyType("distinct");
            }
            else{
                h = new HierarchyImplDouble(file);
                h.setHierachyType("distinct");
            }
        }else{      //create range hierarchy
            h = new HierarchyImplRanges(file);
            h.setHierachyType("range");
        }
        
        //load hierarchy and visualize it
        h.load();
        this.hierarchies.put(h.getName(), h);
        createHierarchyTree(h);
        addItemToComboBox(hierarchiesCombobox, h.getName());
        initAttributesCombo();
//        System.out.println((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));
//        System.out.println(Runtime.getRuntime().totalMemory());
//        System.out.println(Runtime.getRuntime().totalMemory());
    }
    
    private List<String> findHierarchyType(String file){
        List<String> result = new ArrayList<>();
        BufferedReader br;
        String line;
        try {
            br = new BufferedReader(new FileReader(file));

            while ((line = br.readLine()) != null) {
                //System.out.println(line);
                if(line.trim().isEmpty())
                    break;
                
                //find if distinct or range hierarchy
                if(line.trim().equalsIgnoreCase("distinct")){
                    result.add("distinct");
                    continue;
                } else if (line.trim().equalsIgnoreCase("range")){
                    result.add("range");
                    continue;
                }
                
                //find if int, double or string
                String[] tokens = line.split(" ");
                if(tokens[0].equalsIgnoreCase("type")){
                    result.add(tokens[1]);
                }
            }
        } catch (IOException ex) {
            Logger.getLogger(HierarchyPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
  
        return result;
    }
    
    private void addItemToComboBox(JComboBox combobox, String newItem){
        boolean exists = false;
        for (int index=0; index < combobox.getItemCount() && !exists; index++) {
          if (newItem.equals(combobox.getItemAt(index))) {
            exists = true;
          }
        }
        if (!exists) {
          combobox.addItem(newItem);
        }
        combobox.setSelectedItem(newItem);
    }
    
    public void export(String dir){
        for (String hierarchy : hierarchies.keySet()){
            
            //build file path to export hierarchy
            StringBuilder file = new StringBuilder();
            file.append(dir);
            file.append("/");
            /////////////////////////////////////////////////////
            if(hierarchies.get(hierarchy).getRoot() instanceof Range){
               file.append("range_"); 
            } else {
                file.append("distinct_");
            }
            file.append("hier_");
            file.append(hierarchy);
            file.append(".txt");
            System.out.println("Exporting hierarchy " + hierarchy + " to file " + file.toString());
            hierarchies.get(hierarchy).export(file.toString());
        }
    }

    
    @Override
    public void actionPerformed(ActionEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public void setDataset(Data d){
        this.dataset = d;
        initAttributesCombo();
    }
    
    public void initAttributesCombo(){
        
        if(this.dataset == null || !this.panelIsVisible){
            return;
        }
//        System.out.println("init Components");
        jLabel1.setVisible(true);
        reload.setVisible(true);
        attributesCombobox.setVisible(true);
        
        
        this.attributesCombobox.removeAllItems();
        
        String selectedItem = (String)hierarchiesCombobox.getSelectedItem();
        Hierarchy h = hierarchies.get(selectedItem);
        
        for(Integer column : this.dataset.getColumnsTypes().keySet()){
            if(h.getNodesType().equals(this.dataset.getColumnsTypes().get(column))){
//                System.out.println("pushed");
                this.attributesCombobox.addItem(this.dataset.getColumnsPosition().get(column));
            }
            
        }
        
    }
    
    private void visualizeWeights(Map<Object, DefaultMutableTreeNode> nodesMap, Hierarchy h) {
        System.out.println("Visualize weights");
        if ( h.getHierarchyType().equals("distinct")){
            if ( h.getNodesType().equals("double") || h.getNodesType().equals("string") ){
                for(Object n : nodesMap.keySet()){
                    DefaultMutableTreeNode node = nodesMap.get(n);
                    String nodeText = n.toString() + " [" + h.getWeight(n) + "]";
                    node.setUserObject(nodeText);
                }
            }
            else{
                for(Object n : nodesMap.keySet()){
                    DefaultMutableTreeNode node = nodesMap.get(n);
                    String nodeText = (int)Double.parseDouble(n.toString()) + " [" + h.getWeight(n) + "]";
                    node.setUserObject(nodeText);
                }  
            }  
        }
        else{
            if ( h.getNodesType().equals("double") || h.getNodesType().equals("string") ){
                for(Object n : nodesMap.keySet()){
                    DefaultMutableTreeNode node = nodesMap.get(n);
                    String nodeText = n.toString() + " [" + h.getWeight(n) + "]";
                    node.setUserObject(nodeText);
                }
            }
            else{
                Range r = new Range();
                for(Object n : nodesMap.keySet()){
                    DefaultMutableTreeNode node = nodesMap.get(n);
                    r = r.parseRange(n.toString());
                    String nodeText = r.lowerBound.intValue() +"-"+ r.upperBound.intValue() + " [" + h.getWeight(n) + "]";
                    node.setUserObject(nodeText);
                }
            }
        }
        
        trees.get(h.getName()).reload();
    }

    public void autogenerateDistinctHierarchy(String name, String nodesType, String attribute, String sorting, int fanout, int plusMinusFanout) {
        Hierarchy h = null;
        if(nodesType.equals("int") || nodesType.equals("double")){
            h = new AutoHierarchyImplDouble(name, nodesType, "distinct", attribute, sorting, fanout, plusMinusFanout, dataset);
           
        }
        else if(nodesType.equals("string")){
            h = new AutoHierarchyImplString(name, nodesType, "distinct", attribute, sorting, fanout, plusMinusFanout, dataset);
        }
        
        if(h != null){   
            h.autogenerate();
            this.hierarchies.put(h.getName(), h);
            createHierarchyTree(h);
            addItemToComboBox(hierarchiesCombobox, h.getName());
//            initAttributesCombo();
        }
    }

    public void autogenerateRangeHierarchy(String name, String nodesType, Double start, Double end, Double step, int fanout, int plusMinusFanout) {
        Hierarchy h = new AutoHierarchyImplRanges(name, nodesType, "range", start, end, step, fanout, plusMinusFanout);
        h.autogenerate();
        this.hierarchies.put(h.getName(), h);
        createHierarchyTree(h);
        addItemToComboBox(hierarchiesCombobox, h.getName());
        initAttributesCombo();
    
    }
    
//    class RedTreeCellRenderer extends DefaultTreeCellRenderer {
//
//        @Override
//        public Component getTreeCellRendererComponent(
//                    JTree tree, Object value, boolean isSelected,
//                    boolean expanded, boolean leaf, int row, boolean hasFocus) {
//        //System.out.println("Custom renderer called!");
//        JComponent c = (JComponent)super.getTreeCellRendererComponent(
//                        tree, value, isSelected, expanded, leaf, row, hasFocus);
//        
//        String selectedItem = (String)hierarchiesCombobox.getSelectedItem();
//        Hierarchy h = hierarchies.get(selectedItem);
//        if(h!=null && h.getHierarchyType().equals("range")){
////            System.out.println("Range Hierarchy " + parsePoint(value.toString()));
//            boolean valid = true;
//            
//            Range node = new Range();
//            String[] parts = parsePoint(value.toString()).split("-");
//            if(parts.length == 2){
//                node.lowerBound = Double.parseDouble(parts[0]);
//                node.upperBound = Double.parseDouble(parts[1]);
//            }
//            List<Range> chList = h.getChildren(node);
//
//            if(chList != null){
//                for(Range ch : chList){
//                    if((ch.lowerBound < node.lowerBound) || (ch.upperBound > node.upperBound)){
//                        valid = false;
//                    }
//                }
//                //valid = h.validCheck(parsePoint(value.toString()));
//                
//            }
//            if(!valid){
//                //<strong>
//                c.setOpaque(true);
//                //</strong>
//                c.setBackground(Color.RED);
//            } else {
//                c.setOpaque(false);
//                c.setForeground(getTextNonSelectionColor());
//                c.setBackground(getBackgroundNonSelectionColor());
//            }
//            Range parent = (Range)h.getParent(node);
//            if(parent != null){
//                if(node.lowerBound < parent.lowerBound || node.upperBound > parent.upperBound){
//                    //<strong>
//                        c.setOpaque(true);
//                        //</strong>
//                        c.setBackground(Color.RED);
//                }
//            }
//        }
//
//        return c;
//      }
//    }

    public Map<String, Hierarchy> getHierarchies() {
        return hierarchies;
    }

}
